# JavaScript 现代化项目管理：实战准备篇

本指南旨在为 macOS 用户提供一套标准、严谨且高效的 JavaScript 开发工作流。

---

## 0. 核心概念速查 (Terminology)

在配置环境前，必须理清这些工具的基本身份：

| 概念 | 身份 | 作用 |
| :--- | :--- | :--- |
| **JavaScript** | 编程语言 | 逻辑编写的核心。 |
| **Node.js** | 运行时/解释器 | 让 JS 在你的 Mac 上直接运行。 |
| **fnm** | Node 版本管理器 | 随时安装、切换不同的 Node.js 版本（如 18 切换到 20）。 |
| **pnpm** | 包管理器 | 下载、安装并管理项目所需的第三方依赖库（如 axios）。 |
| **npx** | 扩展包执行器 | Node Package Execute。随 npm 安装，用于直接运行包而不必全局安装。 |

---

## 1. Node.js 多版本管理

### 1.1 为什么需要多版本管理？
在实际开发中，不同的项目可能依赖于不同版本的 Node.js。
- **项目 A**：多年前的旧项目，只能在 **Node 16** 下运行。
- **项目 B**：使用最新语法的项目，需要 **Node 22**。
- **服务器一致性**：为了避免线上 Bug，本地开发环境必须切换到与服务器完全一致的版本。

### 1.2 有哪些工具？
常见的版本管理器包括：
- **nvm**：老牌、流行，但使用 Shell 脚本编写，启动终端时会有明显的延迟。
- **n**：交互式简单，但在管理权限和版本隔离上稍逊。
- **Volta**：号称免配置，但有时会对工具链劫持过多。
- **fnm**：后起之秀。

### 1.3 为什么最终选择了 fnm？
**fnm (Fast Node Manager)** 是目前的最佳选择：
- **极致速度**：使用 Rust 编写，几乎没有启动延迟，不会让你的终端变慢。
- **跨平台一致性**：在不同环境下表现稳定。
- **自动切换**：能感知项目目录下的配置文件并自动切换 Node 版本。

### 1.4 安装和使用 fnm
使用 Homebrew 安装：
```bash
brew install fnm
```
*注意：安装后需将初始化代码写入 `~/.zshrc`。直接在终端运行以下命令：*
```bash
echo 'eval "$(fnm env --use-on-cd)"' >> ~/.zshrc
```

**这一句命令的原理拆解（底层逻辑）：**

1.  **启动加载 (Startup)**：当你打开一个新的终端窗口时，Zsh 会通过 `~/.zshrc` 自动触发这条命令。它的本质是让 `fnm` 介入你的终端会话。
2.  **修改 `PATH`（最关键的一步）**：
    -   `fnm env` 会生成一段脚本，其核心操作是修改当前终端的 **`$PATH` 环境变量**。
    -   它会将“fnm 选中的 Node 版本路径”**插入到 `$PATH` 的最前面**。
    -   **结果**：当你输入 `node` 时，系统会通过 `$PATH` 从前到后搜索。由于 fnm 的路径在最前面，系统会“优先加载” fnm 管理的特定版本，从而“覆盖”掉系统自带的默认 Node。
3.  **动态劫持 (`--use-on-cd`)**：
    -   不仅仅是启动时修改一次，这个参数还会给你的 `cd` 命令安装一个“监听器（Hook）”。
    -   **原理**：每当你进入新目录，脚本会瞬间检查目录中的 `.node-version` 文件。如果版本变了，它会**即时更新当前终端的 `$PATH`**，将新的 Node 路径再次插入最前面。
4.  **`eval "$( ... )"` 的角色**：
    -   `fnm env` 只是“打印脚本内容”的文员。
    -   `$( ... )` 负责把打印出来的内容打包。
    -   `eval` 则是真正拥有权限的“执行官”，由它负责将这些涉及到环境变量修改的代码在当前的 Zsh 环境中运行。如果没有它，一切修改都无法影响到你当前的终端会话。

**常用指令：**
```bash
fnm install 20    # 安装版本 20
fnm use 20        # 切换到版本 20
fnm list         # 查看本地已安装的所有版本
```

---

## 2. 包管理

### 2.1 为什么需要包管理？
现代开发不再“重复造轮子”。我们需要引入现成的“依赖库”（如日期处理 Day.js）。包管理器负责这些库的下载、版本更新、依赖冲突处理及共享。

### 2.2 有哪些包管理工具？
- **npm**：官方自带。历史上曾因速度慢、无版本锁定被诟病，虽然后期补齐了功能，但其 `node_modules` 结构依然导致严重的磁盘空间浪费。
- **yarn**：由 Facebook 推出。它是 **Lockfile（版本锁定）** 的鼻祖。你在老项目中经常会看到 `yarn.lock` 文件。虽然它曾是速度和稳定的代名词，但由于不同版本间（v1 vs v4）改动巨大且依然占用大量磁盘，目前地位已被 pnpm 撼动。

### 2.3 为什么最终选择了 pnpm？
**pnpm (Performant npm)** 解决了行业多年来的痛点：
- **节省磁盘空间**：所有项目的包都存在全局缓存中。如果 10 个项目都用了 React，它在磁盘上只存一份，其它项目通过“硬链接”引用。
- **安装飞快**：由于有全局缓存，已下载过的包几乎瞬间安装完成。
- **安全性**：杜绝了“幽灵依赖”（即你只能调用你显式安装的包，不能偷用包的包）。

### 2.4 安装和使用 pnpm
使用 Homebrew 安装：
```bash
brew install pnpm
```

**常用指令分类速查：**

| 分类 | 指令 | 说明 |
| :--- | :--- | :--- |
| **项目初始化** | `pnpm init` | 初始化项目，生成 `package.json`。 |
| **安装依赖** | `pnpm install` | (简写 `i`) 安装 `package.json` 中的所有依赖。 |
| | `pnpm add <pkg>` | 安装包并写入 `dependencies`。 |
| | `pnpm add -D <pkg>` | 安装包并写入 `devDependencies` (开发依赖)。 |
| | `pnpm add -g <pkg>` | 全局安装包。 |
| **移除/更新** | `pnpm remove <pkg>` | (简写 `rm`) 卸载包并从清单删除。 |
| | `pnpm update` | (简写 `up`) 遵循版本规范更新依赖。 |
| **执行脚本** | `pnpm <script>` | **(推荐)** 运行自定义脚本。如 `pnpm dev` 即运行 `next dev`。 |
| | `pnpm run <script>`| 通用写法。当脚本名与内置命令冲突时需使用（见下文）。 |
| **现代执行器** | `pnpm exec <bin>` | 运行项目本地安装的工具二进制文件。 |
| | `pnpm dlx <pkg>` | 下载并运行临时包，不安装到项目环境。 |
| | `pnpm create <pkg>`| 调用脚手架初始化项目（如 `pnpm create vite`）。 |
| **查询/诊断** | `pnpm list` | (简写 `ls`) 列出当前项目安装的所有依赖。 |
| | `pnpm outdated` | 检查是否有依赖可以更新。 |
| | `pnpm why <pkg>` | 查看某个包被安装的原因（依赖溯源）。 |
| **管理与维护** | `pnpm store prune` | **(核心)** 清理全局存储中不再被使用的包，释放空间。 |
| | `pnpm prune` | 移除 `node_modules` 中未在 `package.json` 定义的包。 |
| | `pnpm import` | 从 `npm` 或 `yarn` 的锁定文件生成 `pnpm-lock.yaml`。 |

---

## 3. 核心心智：环境隔离 (Environment Isolation)

在继续动手之前，你需要理解现代 JS 工程化中最核心的一条准则：**将项目视为一个完全独立的沙箱。**

### 3.1 核心洞见：JS 环境隔离的“彻底”与“不彻底”

如果你有 Python 背景，可能会觉得 JS 的隔离方式有些奇异。这里有一个深刻的洞见：**默认情况下，JS 的项目沙箱是不彻底的。**

*   **物理上的彻底隔离（库）**：`pnpm` 通过 `node_modules` 实现了第三方库在物理层面的完全独立。每个项目都有自己的库文件。
*   **默认的共享（解释器）**：与 Python `venv` 会物理地拷贝一个 `python` 解释器副本不同，Node.js 运行时默认是全局唯一的。如果你直接在终端运行 `node`，它永远指向系统路径里的那个版本。

**既然如此，我们如何实现真正的“项目闭环”？**

方案并非“物理拷贝”，而是通过 **fnm + `.node-version` 实现的“逻辑补全”**：
- **fnm 自动切换**：这并非简单的版本切换，它实际上是在终端层面建立了一个**映射钩子**。
- **逻辑打包**：每当你 `cd` 进入目录，fnm 就像魔术一样将当前终端的 `node` 指令重映射到项目所需的特定版本。这种**“按需锚定”**在效果上等同于为项目打包了一个专属解释器。

**结论**：在现代 JS 工作流中，我们不是物理地把 Node.js “塞进”项目，而是通过 `fnm` 将项目环境“锚定”到了特定的版本上。这种物理上的不彻底，通过逻辑上的精确补全，最终构成了完美的工程化闭环。

### 3.2 物理隔离：pnpm 的内容寻址存储
如果你只用过 npm/yarn，你会发现 `node_modules` 极其臃肿。pnpm 改变了这一点：
- **硬链接 (Hard Link)**：所有项目的包实际上都存在磁盘的一个“公共仓库”里。项目里的文件只是一个指向这里的“快捷方式”。
- **隔离性**：这种结构确保了项目 A 绝不会误用项目 B 的包，即使它们引用了同一个库的不同版本。

---

通过上述工具的组合，你已经构建了一个坚实的基础。接下来，请阅读 **[12_JS_工程化最佳实践](./12_JS_工程化最佳实践.md)**，了解如何针对具体业务场景开启你的项目。
